{"version":3,"sources":["SortingAlgorithim/MergeSort.js","SortingAlgorithim/QuickSort.js","SortingAlgorithim/HeapSort.js","SortingVisualiser/SortingVisualiser.jsx","SortingAlgorithim/BubbleSort.js","App.js","serviceWorker.js","index.js"],"names":["getMergeSortAnimations","array","animations","length","mergeSortHelper","arr","middle","Math","floor","left","slice","right","mainArray","leftArray","rightArray","i","j","k","push","doMerge","getQuickSortAnimations","quickSort","low","high","animation","pi","pivot","temp","partition","getHeapSortAnimations","n","Heapify","BuildMaxHeap","Swap","HeapSort","largest","l","r","ANIMATION_SPEED_MS","SortingVisualiser","props","state","disableButton","this","resetArray","min","max","random","setState","enableDisable","arrayBars","document","getElementsByClassName","barOneIdx","barTwoIdx","barOneStyle","style","barTwoStyle","color","setTimeout","backgroundColor","newHeight","height","x","speed","getElementById","display","animate","bubbleSort","class","map","value","index","className","key","type","id","onClick","Number","alert","GetValue","mergeSort","updateInfomation","dictionaryOfInfo","mergeSortInfomation","quickSortInfomation","bubbleSortInfomation","heapSort","heapSortInfomation","window","location","reload","React","Component","info","querySelector","innerHTML","Title","Description","Complexitiy","App","Boolean","hostname","match","ReactDOM","render","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.1c2e5d6a.chunk.js","sourcesContent":["export function getMergeSortAnimations(array, animations) {\r\n  \r\n  if (array.length <= 1) return array;\r\n  \r\n  mergeSortHelper(array, animations);\r\n\r\n  return animations;\r\n}\r\n\r\nfunction mergeSortHelper(arr,animations,) {\r\n  if (arr.length <= 1) return arr;\r\n\r\n  //segment array \r\n  const middle = Math.floor(arr.length / 2);\r\n  const left = arr.slice(0, middle);\r\n  const right = arr.slice(middle, arr.length);\r\n\r\n  mergeSortHelper(left, animations); // pass left array\r\n  mergeSortHelper(right, animations);// pass right array\r\n\r\n  doMerge(arr, left, right, animations);\r\n}\r\n\r\nfunction doMerge(mainArray, leftArray, rightArray, animations) {\r\n  let i = 0;\r\n  let j = 0;\r\n  let k = 0;\r\n  \r\n  while (i < leftArray.length && j < rightArray.length) {\r\n    // These are the values that we're comparing; we push them once\r\n    // to change their color.\r\n    animations.push([i, j, true]);\r\n    // These are the values that we're comparing; we push them a second\r\n    // time to revert their color.\r\n    animations.push([i, j, true]);\r\n    if (leftArray[i] <= rightArray[j]) {\r\n      // We overwrite the value at index k in the original array with the\r\n      // value at index i in the left array.\r\n      animations.push([k, leftArray[i], false]);\r\n      mainArray[k] = leftArray[i];\r\n      i++;\r\n    } else {\r\n      // We overwrite the value at index k in the original array with the\r\n      // value at index j in the right array.\r\n      animations.push([k, rightArray[j], false]);\r\n      \r\n      mainArray[k] = rightArray[j];\r\n      j++;\r\n    }\r\n    k++;\r\n  }\r\n  while (i < leftArray.length) {\r\n    // These are the values that we're comparing; we push them once\r\n    // to change their color.\r\n    animations.push([i, i, true]);\r\n    // These are the values that we're comparing; we push them a second\r\n    // time to revert their color.\r\n    animations.push([i, i, true]);\r\n    // We overwrite the value at index k in the original array with the\r\n    // value at index i in the leftArray array.\r\n    animations.push([k, leftArray[i], false]);\r\n\r\n    mainArray[k++] = leftArray[i++];\r\n  }\r\n  while (j < rightArray.length) {\r\n    // These are the values that we're comparing; we push them once\r\n    // to change their color.\r\n    animations.push([j, j, true]);\r\n    // These are the values that we're comparing; we push them a second\r\n    // time to revert their color.\r\n    animations.push([j, j, true]);\r\n    // We overwrite the value at index k in the original array with the\r\n    // value at index j in the rightArray array.\r\n    animations.push([k, rightArray[j], false]);\r\n\r\n    mainArray[k++] = rightArray[j++];\r\n  }\r\n}","export function getQuickSortAnimations(array, animations) {\r\n  \r\n    if (array.length <= 1) return array;\r\n    \r\n    quickSort(array, 0, array.length - 1, animations);\r\n  \r\n    return animations;\r\n  }\r\n\r\n  function quickSort(arr, low, high, animation){\r\n        if (low < high)\r\n        {\r\n            /* pi is partitioning index, arr[pi] is now\r\n            at right place */\r\n            let pi = partition(arr, low, high, animation);\r\n\r\n            quickSort(arr, low, pi - 1, animation);  // Before pi\r\n            quickSort(arr, pi + 1, high, animation); // After pi\r\n        }\r\n    }\r\n\r\n    /* This function takes last element as pivot, places\r\n   the pivot element at its correct position in sorted\r\n    array, and places all smaller (smaller than pivot)\r\n   to left of pivot and all greater elements to right\r\n   of pivot */\r\n    function partition (arr, low, high, animation)\r\n    {\r\n\r\n        // pivot (Element to be placed at right position)\r\n        const pivot = arr[high];  \r\n    \r\n        let i = (low - 1)  // Index of smaller element\r\n\r\n        animation.push([low, high, true]);\r\n        animation.push([low, high, true]);\r\n\r\n        animation.push([low, pivot, false]);\r\n\r\n        for (let j = low; j <= high - 1; j++)\r\n        {\r\n            // If current element is smaller than the pivot\r\n            if (arr[j] < pivot)\r\n            {\r\n                i++;    // increment index of smaller element\r\n\r\n                let temp = arr[i]; // swap\r\n                arr[i] = arr[j];\r\n                arr[j] = temp;\r\n\r\n                animation.push([i, i, true]);\r\n                animation.push([i, i, true]);\r\n\r\n                animation.push([i, arr[i], false]);\r\n\r\n                animation.push([j, i, true]);\r\n                animation.push([j, i, true]);\r\n\r\n                animation.push([j, arr[j], false]);\r\n            }\r\n        }\r\n\r\n        i++;\r\n        let temp = arr[i]; \r\n        arr[i] = arr[high]; \r\n        arr[high] = temp;\r\n\r\n        animation.push([i, i, true]);\r\n        animation.push([i, i, true]);\r\n\r\n        animation.push([i, arr[i], false]);\r\n\r\n        animation.push([high, i, true]);\r\n        animation.push([high, i, true]);\r\n\r\n        animation.push([high, arr[high], false]);\r\n\r\n        return i;\r\n    }\r\n\r\n\r\n","export function getHeapSortAnimations(array, animations) {\r\n  \r\n    if (array.length <= 1) return array;\r\n    \r\n    HeapSort(array, animations);\r\n  \r\n    return animations;\r\n}\r\n\r\n  function HeapSort(arr, animations){\r\n    const n = arr.length;\r\n    // Build heap (rearrange array) \r\n    BuildMaxHeap(arr, n, animations);\r\n\r\n    // One by one extract an element from heap \r\n    for(let i = n - 1; i >= 0; i--){\r\n      Swap(arr, 0, i, animations);// Move current root to end\r\n      Heapify(arr, i, 0, animations);//// Move current root to end\r\n    }\r\n  }\r\n\r\n  function BuildMaxHeap(arr, n, animations){\r\n    for(let i = n / 2 - 1; i >= 0; i--){\r\n      Heapify(arr, n, i, animations);\r\n    }\r\n  }\r\n\r\n  function Heapify(arr, n, i, animations){\r\n    let largest = i; // Initialize largest as root \r\n    let l = 2*i + 1; // left = 2*i + 1 \r\n    let r = 2*i + 2; // right = 2*i + 2 \r\n  \r\n    // If left child is larger than root \r\n    if (l < n && arr[l] > arr[largest]){\r\n        largest = l; \r\n    }\r\n  \r\n    // If right child is larger than largest so far \r\n    if (r < n && arr[r] > arr[largest]) {\r\n        largest = r; \r\n    }\r\n    // If largest is not root \r\n    if (largest !== i) \r\n    { \r\n        Swap(arr, i, largest, animations); \r\n  \r\n        // Recursively heapify the affected sub-tree \r\n        Heapify(arr, n, largest, animations); \r\n    } \r\n  }\r\n\r\n  function Swap(arr, i, j, animations){\r\n    let temp = arr[i];  \r\n    arr[i] = arr[j];\r\n    arr[j] = temp;\r\n\r\n    animations.push([i, i, true]);\r\n    animations.push([i, i, true]);\r\n\r\n    animations.push([i, arr[i], false]);\r\n\r\n    animations.push([j, i, true]);\r\n    animations.push([j, i, true]);\r\n\r\n    animations.push([j, arr[j], false]);\r\n  }","import React from 'react';\r\nimport {getMergeSortAnimations} from '../SortingAlgorithim/MergeSort.js';\r\nimport {getQuickSortAnimations} from '../SortingAlgorithim/QuickSort.js';\r\nimport {getBubbleSortAnimations} from '../SortingAlgorithim/BubbleSort.js';\r\nimport {getHeapSortAnimations} from '../SortingAlgorithim/HeapSort.js';\r\nimport './SortingVisualiser.css';\r\n\r\n// Change this value for the speed of the animations.\r\nlet ANIMATION_SPEED_MS = 1;\r\n// Change this value for the number of bars (value) in the array.\r\nconst NUMBER_OF_ARRAY_BARS = 300;\r\n// This is the main color of the array bars.\r\nconst PRIMARY_COLOR = '#3D5467';\r\n// This is the color of array bars that are being compared throughout the animations.\r\nconst SECONDARY_COLOR = 'red';\r\n\r\nexport class SortingVisualiser extends React.Component {\r\n    constructor(props){\r\n        super(props);\r\n\r\n        this.state = {\r\n            array: [],\r\n            disableButton: false,\r\n        };\r\n    }\r\n\r\n    componentDidMount(){\r\n        this.resetArray(); // When the application runs for the first time we call the method\r\n    }\r\n    \r\n    resetArray(){\r\n        const array = [];\r\n        for(let i = 0; i < NUMBER_OF_ARRAY_BARS; i++){\r\n            array.push(randomIntFromInterval(5,1000)); // Starting from 5 so we can see the bar on the screen\r\n        }\r\n        this.setState({array}); // Reset to have this array\r\n    }\r\n\r\n    animate(animations){\r\n      this.enableDisable(0, ANIMATION_SPEED_MS);\r\n      const arrayBars = document.getElementsByClassName(\"array-bar\");\r\n      for (let i = 0; i < animations.length; i++) {\r\n          let isColorChange = animations[i][2];\r\n          if (isColorChange) {\r\n            const [barOneIdx, barTwoIdx, move] = animations[i];\r\n            const barOneStyle = arrayBars[barOneIdx].style;\r\n            const barTwoStyle = arrayBars[barTwoIdx].style;\r\n            const color = i % 3 === 0 ? SECONDARY_COLOR : PRIMARY_COLOR;\r\n            setTimeout(() => {\r\n              barOneStyle.backgroundColor = color;\r\n              barTwoStyle.backgroundColor = color;\r\n            }, i * ANIMATION_SPEED_MS);\r\n          } else {\r\n            setTimeout(() => {\r\n              const [barOneIdx, newHeight, move] = animations[i];\r\n              const barOneStyle = arrayBars[barOneIdx].style;\r\n              barOneStyle.height = `${newHeight/1.5}px`;\r\n            }, i * ANIMATION_SPEED_MS);\r\n          }\r\n\r\n          let x = i+2;\r\n          if (x > animations.length){\r\n            this.enableDisable(i, ANIMATION_SPEED_MS);\r\n          }\r\n      }\r\n    }\r\n\r\n    enableDisable(x, speed){\r\n\r\n      setTimeout(() =>{\r\n        let x = document.getElementById(\"buttonsDiv\");\r\n        if (x.style.display === \"none\") {\r\n          x.style.display = \"block\";\r\n        } else {\r\n          x.style.display = \"none\";\r\n        }\r\n      }, x * speed);\r\n      \r\n    }\r\n\r\n    // Merge Sort is a Divide and Conquer algorithm. It divides input array in two halves, calls itself for the two halves and then merges the two sorted halves\r\n    mergeSort(){\r\n        this.animate(getMergeSortAnimations(this.state.array, []));\r\n    }\r\n\r\n    quickSort(){\r\n        this.animate(getQuickSortAnimations(this.state.array, []));\r\n    }\r\n\r\n    bubbleSort(){\r\n        this.animate(getBubbleSortAnimations(this.state.array, []));\r\n    }\r\n\r\n    heapSort(){\r\n      this.animate(getHeapSortAnimations(this.state.array, []));\r\n    }\r\n\r\n    render(){\r\n        const array = this.state.array;\r\n\r\n        return (\r\n            <div class=\"array-container\">\r\n                {array.map((value, index) => (\r\n                    <div\r\n                        className=\"array-bar\"\r\n                        key={index}\r\n                        style={{\r\n                        backgroundColor: PRIMARY_COLOR,\r\n                        height: `${value/1.5}px`,\r\n                        }}>\r\n                        </div>\r\n                ))}\r\n                \r\n                <div>\r\n                  Animation Speed: <input type=\"number\" id=\"anispeed\" min=\"0\" max=\"10\"/>\r\n                  <button class=\"button\" onClick={() => GetValue()}>Set Speed</button>\r\n                </div>\r\n              \r\n                <div id=\"buttonsDiv\">\r\n                  <button class=\"button-go\" onClick={() => this.resetArray()}>New Array</button>\r\n                  <button class=\"button\" onClick={() => {\r\n                      this.mergeSort();\r\n                      updateInfomation(mergeSortInfomation());\r\n                      }}>Merge Sort</button>\r\n                  \r\n                  <button class=\"button\" onClick={() => {\r\n                      this.quickSort();\r\n                      updateInfomation(quickSortInfomation());\r\n                      }}>Quick Sort</button>\r\n                  \r\n                  <button class=\"button\" onClick={() => {\r\n                      this.bubbleSort();\r\n                      updateInfomation(bubbleSortInfomation());\r\n                      }}>Bubble Sort</button>\r\n\r\n                  <button class=\"button\" onClick={() => {\r\n                      this.heapSort();\r\n                      updateInfomation(heapSortInfomation());\r\n                      }}>Heap Sort</button>\r\n                </div>\r\n                <div>\r\n                  <button class=\"button-stop\" onClick={() => window.location.reload()}>Stop Animation</button>\r\n                </div>\r\n                \r\n                <div class=\"algo-infomation\" id=\"info\">\r\n                    <h1 class=\"title\"></h1>\r\n                    <h3 class=\"description\"></h3>\r\n                    <h3 class=\"complexitiy\"></h3>\r\n                </div>\r\n                \r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\n  function randomIntFromInterval(min, max){\r\n    // from https://stackoverflow.com/questions/4959975/generate-random-number-between-two-numbers-in-javascript\r\n    return Math.floor(Math.random() * (max - min + 1) + min)\r\n  }\r\n\r\n  function updateInfomation(info) {\r\n    document.querySelector(\".title\").innerHTML = info.Title;\r\n    document.querySelector(\".description\").innerHTML = info.Description;\r\n    document.querySelector(\".complexitiy\").innerHTML = info.Complexitiy;\r\n  }\r\n\r\n  function mergeSortInfomation(){\r\n      let dictionaryOfInfo = {};\r\n      dictionaryOfInfo.Title = \"Merge Sort\";\r\n      dictionaryOfInfo.Description = \"Merge Sort is a Divide and Conquer algorithm. \" \r\n                        +\"It divides the array in two halves, calls itself for the two halves (using recursion) and then merges the two sorted halves.\";\r\n      dictionaryOfInfo.Complexitiy = \"The complexity is: O(n Log n) \"\r\n                        +\"in all 3 cases (worst, average and best) as merge sort always divides the array into two halves and take linear time to merge two halves\";\r\n    return dictionaryOfInfo;\r\n  }\r\n\r\n  function quickSortInfomation(){\r\n    let dictionaryOfInfo = {};\r\n    dictionaryOfInfo.Title = \"Quick Sort\";\r\n    dictionaryOfInfo.Description = \"Quick Sort is a Divide and Conquer algorithm. \" \r\n                      +\"Similar to merge sort, however it works by selecting a pivot (typically the first or last element in the array), \"\r\n                      +\"then places the element smaller than the pivot left and elements higher than the pivot to the right. Sorting in-place before spliting rather than splitting and then sorting.\";\r\n    dictionaryOfInfo.Complexitiy = \"The complexity is: O(n Log n) \"\r\n                      +\", worst case being O(n^2) when the list is already sorted however this is very rare.\";\r\n    return dictionaryOfInfo;\r\n  }\r\n\r\n  function bubbleSortInfomation(){\r\n    let dictionaryOfInfo = {};\r\n    dictionaryOfInfo.Title = \"Bubble Sort\";\r\n    dictionaryOfInfo.Description = \"Bubble Sort is the simplest sorting algorithm that works by repeatedly swapping the adjacent elements if they are in wrong order.\";\r\n    dictionaryOfInfo.Complexitiy = \"The complexity is: O(n^2), Worst case occurs when array is reverse sorted.\"\r\n                      +\" And Best case O(n) when the array is already sorted. \";\r\n    return dictionaryOfInfo;\r\n  }\r\n\r\n  function heapSortInfomation(){\r\n    let dictionaryOfInfo = {};\r\n    dictionaryOfInfo.Title = \"Heap Sort\";\r\n    dictionaryOfInfo.Description = \"Heap sort is a comparison based sorting technique based on Binary Heap data structure. \"\r\n                      +\"It is similar to selection sort where we first find the maximum element and place the maximum element at the end. We repeat the same process for remaining element. \"\r\n                      +\"Heap sort is an in-place algorithm.\";\r\n    dictionaryOfInfo.Complexitiy = \"The complexity is: O(n Log n) \"\r\n                      +\", the time complexity of heapify is O(Log n)\";\r\n    return dictionaryOfInfo;\r\n  }\r\n  function GetValue(){\r\n    if (document.getElementById('anispeed').value === \"\"){\r\n      ANIMATION_SPEED_MS = 1;\r\n    }\r\n    else{\r\n      ANIMATION_SPEED_MS = Number(document.getElementById('anispeed').value);\r\n    }\r\n    alert(\"Animation will slow down by \" + ANIMATION_SPEED_MS)\r\n  }","export function getBubbleSortAnimations(array, animations) {\r\n  \r\n    if (array.length <= 1) return array;\r\n\r\n    //array = [2,4,1,5,7,6,8,9,10,3];\r\n    //index = [0,1,2,3,4,5,6,7,8,9]\r\n\r\n    bubbleSort(array, animations);\r\n  \r\n    return animations;\r\n  }\r\n\r\n  function bubbleSort(arr, animation){\r\n    if (arr.length <= 1){return arr;}\r\n\r\n    /*Loop through the array reducing its size after each (the largest will be moved to the right so we dont need to compare)\r\n        when the value is greater we swap */\r\n\r\n    const n = arr.length; \r\n    for (let i = 0; i < n - 1; i++){\r\n        for (let j = 0; j < n - i - 1; j++) {\r\n            if (arr[j] > arr[j + 1]) \r\n            {\r\n                //swap\r\n                let temp = arr[j];\r\n                arr[j] = arr[j+1];\r\n                arr[j+1] = temp;\r\n\r\n                animation.push([j, j, true]);\r\n                animation.push([j, j, true]);\r\n\r\n                animation.push([j, arr[j], false]);\r\n\r\n                animation.push([j+1, j, true]);\r\n                animation.push([j+1, j, true]);\r\n\r\n                animation.push([j+1, arr[j+1], false]);\r\n            }\r\n        }\r\n    }\r\n    \r\n  }","import React from 'react';\r\nimport {SortingVisualiser} from './SortingVisualiser/SortingVisualiser.jsx';\r\nimport './App.css';\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <SortingVisualiser></SortingVisualiser>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.1/8 is considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl)\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport App from './App';\r\nimport './index.css';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\n\r\nReactDOM.render(<App/>, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}